# I feel like this one is pretty self explanatory, but it pipes all of the data to OpenAI and adds the returned summary to a file

import os
import json
import utilities
from asyncio import Semaphore, gather
from pydantic import BaseModel
from openai import OpenAI, AsyncOpenAI
from dotenv import dotenv_values

config = {
    **dotenv_values("../.env")
}

client = OpenAI(
  api_key=config["OPENAI_KEY"]
)

async_client = AsyncOpenAI(
       api_key=config["OPENAI_KEY"]
)

reviews_path = "./merged_reviews"
output_path = "./summaries"

def get_prompt(file_content):
     return f'''Create an article in HTML format for the {file_content["company_type"]} {file_content["name"]} with the following requirements: 
              1. This article sub-sections should be: good, great, bad, and ugly. The content of sub-section should reflect the sentiment of the heading. The sub-section headers should be wrapped in HTML <h2></h2> tags. 
              2. Each section shall have 2 paragraphs comprised of 3-5 sentences for each paragraph. Each paragraph should be wrapped in <p></p> tags. 
              3. There shall be no identifiable information, such as the name of the reviewer.
              4. Be as detailed as possible, citing specific examples of the property management company either neglecting their duties or exceeding expectations, and any common themes such as not addressing maintenance concerns, not returning security deposits, poor communication, as well as how many times the company has replied to user reviews. 
              5. Ensure to mention either at the beginning or end of the article that these summary articles are generated by ChatGPT, and is only intended to be a tool to help them find a property management company or rental property. 
              6. When referring to the user-supplied reviews, call them "user reviews". When referring to the generated output from this request, call it "article", such as "in this article...", "this article's intent is to...", etc.
              7. The data shall be returned a single-line string without markdown-style backticks.
              8. The response string shall contain the HTML summary text generated by ChatGPT. Sub-headings shall be contained in <h2></h2> tags, and the text content for those sub-sections shall be contained in <p></p> tags. 
              The data is as follows in JSON format, with the reviews contained in the "reviews" key: ### {json.dumps(file_content, ensure_ascii=True, indent=2)} ###'''


def create_articles(path, out):
        dir_list = utilities.list_files(path)
        for file in dir_list:
          print(file)
          with open(f"{path}/{file}", "r") as input_file:
              file_json = json.load(input_file)
              prompt =  get_prompt(file_json)
              result = client.chat.completions.create(
                model="gpt-4-1106-preview",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant whose job is to summarize real company reviews to create well-balanced articles on local property management companies."},
                    {"role": "user", "content": prompt}
                ]
              )
              with open(f'{out}/{file_json["slug"]}.json', 'w') as output_file:
                  
                  json.dump({**file_json, "summary": json.loads(result.choices[0].message.content)}, output_file,  ensure_ascii=True, indent=2)
                  output_file.close()
          input_file.close()
          return
        
        
async def create_articles_async(file_json):
     prompt = get_prompt(file_json)
     return await async_client.chat.completions.create(
                model="gpt-4-1106-preview",
                messages=[
                    {"role": "system", "content": "You are a helpful assistant whose job is to summarize real company reviews to create well-balanced articles on local property management companies."},
                    {"role": "user", "content": prompt}
                ],
              )
        
async def rate_limiter(file_path: str, semaphore: Semaphore):
     async with semaphore:
          with open(file_path, "r") as input_file:
            file_json = json.load(input_file)
            input_file.close()
            return await {
                "name": file_json["name"],
                "summary": create_articles_async(file_json, semaphore)                
            }
     
semaphore = Semaphore(3)

async def async_driver(path, out):
     ret = []
     file_list = utilities.list_files(path)
     tasks = [rate_limiter(f"{path}{file}", semaphore) for file in file_list]
     for response in gather(tasks):
          ret = 
          
          



# create_articles(reviews_path, output_path)